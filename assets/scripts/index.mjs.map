{
  "version": 3,
  "sources": ["../../../src/assets/scripts/constants.mjs", "../../../src/assets/scripts/components/ThemeToggle.mjs", "../../../src/assets/scripts/index.mjs"],
  "sourcesContent": ["export const Themes = {\n  LIGHT: 'light',\n  DARK: 'dark',\n};\n\nexport const THEME_KEY = 'theme';\n\nexport const copyToClipboardButtonStrings = {\n  default: 'Copy',\n  ariaLabel: 'Copy to clipboard',\n  copied: 'Copied',\n};\n", "/**\n * @typedef ThemeToggleProps\n * @property {HTMLElement} toggleElement The element to be toggled.\n * @property {string} initialTheme The initial theme for the switch, which must exist in the `themes` map.\n * @property {(theme: string) => void} setTheme Callback to set the current theme, both on mount and on toggle. Logic to update your UI should go here.\n * @property {(theme: string) => void} [setCachedTheme] Optionally caches the theme on toggle. Called alongside `setTheme` when the toggle element is clicked.\n * @property {string | null} [cachedTheme] The cached theme, if one exists. If specified, this takes priority over `defaultTheme` and is used to initialize the component.\n * @property {Record<string, string>} themes A map of theme state transitions. On toggle, the current theme will get set to the next theme specified in this map. Note that all keys must be reachable\u2014i.e., they must be values in the map. Likewise, all values need to be keys so that toggling from that state does not yield an indeterminate state.\n */\n\nexport default class ThemeToggle {\n  /**\n   * @param {ThemeToggleProps} props The props with which to initialize this theme toggle.\n   * @throws if the initial theme, or any other theme in the theme map, is unreachable or has no target state.\n   */\n  constructor(props) {\n    this.props = props;\n    this._validateThemes();\n    this.props.toggleElement.addEventListener('click', () => this.toggle());\n    this._setTheme(this.props.initialTheme);\n  }\n\n  /** The next theme that will get set when `toggle` is called. */\n  get nextTheme() {\n    return this.props.themes[this.theme];\n  }\n\n  /** Validates all themes supplied to the toggle. If a theme is not recognized (i.e., unspecified in the theme map), throws an error. */\n  _validateThemes() {\n    const uniqueThemeKeys = new Set(Object.keys(this.props.themes));\n    const uniqueThemeValues = new Set(Object.values(this.props.themes));\n    const allUniqueThemes = new Set([...uniqueThemeKeys, ...uniqueThemeValues, this.props.initialTheme]);\n\n    if (allUniqueThemes.size !== uniqueThemeKeys.size || allUniqueThemes.size !== uniqueThemeValues.size) {\n      throw new Error(`One or more themes do not have a target state transition or are unreachable from other states.`);\n    }\n  }\n\n  /** Sets the current theme to the specified theme internally and invokes the `setTheme` callback prop, if it exists. */\n  _setTheme(newTheme) {\n    this.theme = newTheme;\n    this.props.setTheme(newTheme);\n  }\n\n  /** Cycles through the theme map, toggling the current theme to the next theme. */\n  toggle() {\n    const newTheme = this.nextTheme;\n    this._setTheme(newTheme);\n    this.props.setCachedTheme?.(newTheme);\n  }\n}\n", "import { THEME_KEY, Themes, copyToClipboardButtonStrings } from './constants.mjs';\nimport ThemeToggle from './components/ThemeToggle.mjs';\n\nconst themeToggleElement = document.getElementById('theme-toggle');\n\nif (themeToggleElement) {\n  const cachedTheme = localStorage.getItem(THEME_KEY);\n  const preferredTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? Themes.DARK : Themes.LIGHT;\n\n  // eslint-disable-next-line no-unused-vars\n  const themeToggle = new ThemeToggle({\n    toggleElement: themeToggleElement,\n    initialTheme: cachedTheme ?? preferredTheme,\n    setTheme: (theme) => {\n      document.documentElement.dataset[THEME_KEY] = theme;\n      if (theme === Themes.DARK) {\n        themeToggleElement.setAttribute('src', '/assets/images/icons/sunny.png');\n      } else {\n        themeToggleElement.setAttribute('src', '/assets/images/icons/moon.png');\n      }\n    },\n    setCachedTheme: (theme) => localStorage.setItem(THEME_KEY, theme),\n    themes: {\n      [Themes.LIGHT]: Themes.DARK,\n      [Themes.DARK]: Themes.LIGHT,\n    },\n  });\n}\n\ndocument.querySelectorAll('code[class*=language-]').forEach((codeBlock) => {\n  // TODO: This is my only option until https://github.com/11ty/eleventy-plugin-syntaxhighlight/issues/72 is addressed\n  codeBlock.setAttribute('tabindex', 0);\n\n  if (codeBlock.getAttribute('data-copyable')) {\n    const code = codeBlock.innerText;\n    const copyCodeButton = document.createElement('button');\n    copyCodeButton.className = 'copy-code-button fs-sm';\n    copyCodeButton.innerText = copyToClipboardButtonStrings.default;\n    // Set an aria label explicitly to clarify the button's action a bit better for screen reader users; sighted users should be able to relate \"Copy\" to the code block in which the button is positioned\n    copyCodeButton.setAttribute('aria-label', copyToClipboardButtonStrings.ariaLabel);\n    copyCodeButton.type = 'button';\n    codeBlock.parentElement.append(copyCodeButton);\n\n    // Accessible alert whose inner text changes when we copy.\n    const copiedAlert = document.createElement('span');\n    copiedAlert.setAttribute('role', 'alert');\n    copiedAlert.classList.add('screen-reader-only');\n    codeBlock.parentElement.append(copiedAlert);\n\n    copyCodeButton.addEventListener('click', () => {\n      window.navigator.clipboard.writeText(code);\n      copyCodeButton.classList.add('copied');\n      copyCodeButton.innerText = copyToClipboardButtonStrings.copied;\n      copiedAlert.innerText = copyToClipboardButtonStrings.copied;\n\n      setTimeout(() => {\n        copyCodeButton.classList.remove('copied');\n        copyCodeButton.innerText = copyToClipboardButtonStrings.default;\n        copiedAlert.innerText = '';\n      }, 2000);\n    });\n  }\n});\n"],
  "mappings": "AAAO,IAAMA,EAAS,CACpB,MAAO,QACP,KAAM,MACR,EAEaC,EAAY,QAEZC,EAA+B,CAC1C,QAAS,OACT,UAAW,oBACX,OAAQ,QACV,ECDA,IAAqBC,EAArB,KAAiC,CAK/B,YAAYC,EAAO,CACjB,KAAK,MAAQA,EACb,KAAK,gBAAgB,EACrB,KAAK,MAAM,cAAc,iBAAiB,QAAS,IAAM,KAAK,OAAO,CAAC,EACtE,KAAK,UAAU,KAAK,MAAM,YAAY,CACxC,CAGA,IAAI,WAAY,CACd,OAAO,KAAK,MAAM,OAAO,KAAK,KAAK,CACrC,CAGA,iBAAkB,CAChB,IAAMC,EAAkB,IAAI,IAAI,OAAO,KAAK,KAAK,MAAM,MAAM,CAAC,EACxDC,EAAoB,IAAI,IAAI,OAAO,OAAO,KAAK,MAAM,MAAM,CAAC,EAC5DC,EAAkB,IAAI,IAAI,CAAC,GAAGF,EAAiB,GAAGC,EAAmB,KAAK,MAAM,YAAY,CAAC,EAEnG,GAAIC,EAAgB,OAASF,EAAgB,MAAQE,EAAgB,OAASD,EAAkB,KAC9F,MAAM,IAAI,MAAM,gGAAgG,CAEpH,CAGA,UAAUE,EAAU,CAClB,KAAK,MAAQA,EACb,KAAK,MAAM,SAASA,CAAQ,CAC9B,CAGA,QAAS,CACP,IAAMA,EAAW,KAAK,UACtB,KAAK,UAAUA,CAAQ,EACvB,KAAK,MAAM,iBAAiBA,CAAQ,CACtC,CACF,EC/CA,IAAMC,EAAqB,SAAS,eAAe,cAAc,EAEjE,GAAIA,EAAoB,CACtB,IAAMC,EAAc,aAAa,QAAQC,CAAS,EAC5CC,EAAiB,OAAO,WAAW,8BAA8B,EAAE,QAAUC,EAAO,KAAOA,EAAO,MAGlGC,EAAc,IAAIC,EAAY,CAClC,cAAeN,EACf,aAAcC,GAAeE,EAC7B,SAAWI,GAAU,CACnB,SAAS,gBAAgB,QAAQL,CAAS,EAAIK,EAC1CA,IAAUH,EAAO,KACnBJ,EAAmB,aAAa,MAAO,gCAAgC,EAEvEA,EAAmB,aAAa,MAAO,+BAA+B,CAE1E,EACA,eAAiBO,GAAU,aAAa,QAAQL,EAAWK,CAAK,EAChE,OAAQ,CACN,CAACH,EAAO,KAAK,EAAGA,EAAO,KACvB,CAACA,EAAO,IAAI,EAAGA,EAAO,KACxB,CACF,CAAC,CACH,CAEA,SAAS,iBAAiB,wBAAwB,EAAE,QAASI,GAAc,CAIzE,GAFAA,EAAU,aAAa,WAAY,CAAC,EAEhCA,EAAU,aAAa,eAAe,EAAG,CAC3C,IAAMC,EAAOD,EAAU,UACjBE,EAAiB,SAAS,cAAc,QAAQ,EACtDA,EAAe,UAAY,yBAC3BA,EAAe,UAAYC,EAA6B,QAExDD,EAAe,aAAa,aAAcC,EAA6B,SAAS,EAChFD,EAAe,KAAO,SACtBF,EAAU,cAAc,OAAOE,CAAc,EAG7C,IAAME,EAAc,SAAS,cAAc,MAAM,EACjDA,EAAY,aAAa,OAAQ,OAAO,EACxCA,EAAY,UAAU,IAAI,oBAAoB,EAC9CJ,EAAU,cAAc,OAAOI,CAAW,EAE1CF,EAAe,iBAAiB,QAAS,IAAM,CAC7C,OAAO,UAAU,UAAU,UAAUD,CAAI,EACzCC,EAAe,UAAU,IAAI,QAAQ,EACrCA,EAAe,UAAYC,EAA6B,OACxDC,EAAY,UAAYD,EAA6B,OAErD,WAAW,IAAM,CACfD,EAAe,UAAU,OAAO,QAAQ,EACxCA,EAAe,UAAYC,EAA6B,QACxDC,EAAY,UAAY,EAC1B,EAAG,GAAI,CACT,CAAC,CACH,CACF,CAAC",
  "names": ["Themes", "THEME_KEY", "copyToClipboardButtonStrings", "ThemeToggle", "props", "uniqueThemeKeys", "uniqueThemeValues", "allUniqueThemes", "newTheme", "themeToggleElement", "cachedTheme", "THEME_KEY", "preferredTheme", "Themes", "themeToggle", "ThemeToggle", "theme", "codeBlock", "code", "copyCodeButton", "copyToClipboardButtonStrings", "copiedAlert"]
}
